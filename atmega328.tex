\begin{lstlisting}[caption=atmega328p\_firm.ino ,label=hoge,language=C]
  #include <Wire.h>
  #include <MsTimer2.h>
  #include <SerialCommand.h>
  
  volatile char num_signal_pattern[11][2] = {
    {0b00000000, 0b10000000}, // 0
    {0b00000100, 0b00000000}, // 1
    {0b00001000, 0b00000000}, // 2
    {0b00000000, 0b00000001}, // 3
    {0b00000000, 0b00000010}, // 4
    {0b00000000, 0b00000100}, // 5
    {0b00000000, 0b00001000}, // 6
    {0b00000000, 0b00010000}, // 7
    {0b00000000, 0b00100000}, // 8
    {0b00000000, 0b01000000}, // 9
    {0b00000000, 0b00000000}, // _
  };
  
  volatile char dot_signal_pattern[4][2] = {
    {0b00000000, 0b00000000}, // 00
    {0b00000001, 0b00000000}, // 01
    {0b00000010, 0b00000000}, // 10
    {0b00000011, 0b00000000}, // 11
  };


  
  int cycleNum = 0;
  volatile char display_pattern[8][2] = {
    {0b00000000, 0b10000000}, // nix0
    {0b00000000, 0b01000000}, // nix1
    {0b00000001, 0b00000000}, // nix2
    {0b00000000, 0b00000100}, // nix3
    {0b00000000, 0b00010000}, // nix4
    {0b00000001, 0b00000000}, // nix5
    {0b00000000, 0b10000000}, // nix6
    {0b00000000, 0b10000000}, // nix7
  };
  
  volatile bool anode_signal_pattern[8][8] = {
    {1,1,1,1,1,1,1,0},
    {1,1,1,1,1,1,0,1},
    {1,1,1,1,1,0,1,1},
    {1,1,1,1,0,1,1,1},
    {1,1,1,0,1,1,1,1},
    {1,1,0,1,1,1,1,1},
    {1,0,1,1,1,1,1,1},
    {0,1,1,1,1,1,1,1},
  };
  
  volatile char cycle = 0;
  volatile char before_cycle = 0;
  
  
  
  void timer_interrupt(){
    // anode select counter
    cycle++;
    if(cycle > 7){
      cycle = 0;
    }
  
    digitalWrite(before_cycle+2,1);
    
    shiftOut(10,11,MSBFIRST, display_pattern[cycle][0]);
    shiftOut(10,11,MSBFIRST, display_pattern[cycle][1]);
  
    digitalWrite(12,LOW);
    digitalWrite(12,HIGH);
    digitalWrite(12,LOW);
  
    // force
    /*
    digitalWrite(2,anode_signal_pattern[cycle][0]);
    digitalWrite(3,anode_signal_pattern[cycle][1]);
    digitalWrite(4,anode_signal_pattern[cycle][2]);
    digitalWrite(5,anode_signal_pattern[cycle][3]);
    digitalWrite(6,anode_signal_pattern[cycle][4]);
    digitalWrite(7,anode_signal_pattern[cycle][5]);
    digitalWrite(8,anode_signal_pattern[cycle][6]);
    digitalWrite(9,anode_signal_pattern[cycle][7]);
    */
    
    digitalWrite(cycle+2,0);
  
    before_cycle = cycle;
  }
  
  // serial command control object
  SerialCommand SCmd;
  
  void setup(){
    Wire.begin();
  
    Serial.begin(9600);  
  
    // serial command
    uint8_t steps = 0;
    uint8_t addr = 0x2F;
    
    Wire.beginTransmission(addr);
    Wire.write(steps);
    Wire.endTransmission();
  
    pinMode(2,OUTPUT);
    pinMode(3,OUTPUT);
    pinMode(4,OUTPUT);
    pinMode(5,OUTPUT);
    pinMode(6,OUTPUT);
    pinMode(7,OUTPUT);
    pinMode(8,OUTPUT);
    pinMode(9,OUTPUT);
    pinMode(10,OUTPUT);
    pinMode(11,OUTPUT);
    pinMode(12,OUTPUT);
  
    pinMode(13,OUTPUT);
    digitalWrite(13, HIGH);
  
    SCmd.addCommand("num", set_num);
    SCmd.addCommand("dot", set_dot);
    SCmd.addDefaultHandler(error);
  
  
    MsTimer2::set(0.1,timer_interrupt);
    MsTimer2::start();
  }
  
  int translate_num(char input_char){
    switch(input_char){
      case '0':
        return 0;
        break;
  
      case '1':
        return 1;
        break;
  
      case '2':
        return 2;
        break;
  
      case '3':
        return 3;
        break;
  
      case '4':
        return 4;
        break;
  
      case '5':
        return 5;
        break;
        
      case '6':
        return 6;
        break;
  
      case '7':
        return 7;
        break;
  
      case '8':
        return 8;
        break;
  
      case '9':
        return 9;
        break;
  
      case 'n':
        return 10;
        break;
    }
  }
  
  
  
  void set_num(){
    char dot_save[8] = {
      0, // nix0
      0, // nix1
      0, // nix2
      0, // nix3
      0, // nix4
      0, // nix5
      0, // nix6
      0, // nix7
    };
    
    char* arg = SCmd.next();
  
    //save dot
    for(char n = 0; n < 8; n++){
      dot_save[n] = (display_pattern[n][0] & 0b00000011);
    }
  
    memcpy(display_pattern[0], (void*)num_signal_pattern[translate_num(arg[0])], 2);
    memcpy(display_pattern[1], (void*)num_signal_pattern[translate_num(arg[1])], 2);
    memcpy(display_pattern[2], (void*)num_signal_pattern[translate_num(arg[2])], 2);
    memcpy(display_pattern[3], (void*)num_signal_pattern[translate_num(arg[3])], 2);
    memcpy(display_pattern[4], (void*)num_signal_pattern[translate_num(arg[4])], 2);
    memcpy(display_pattern[5], (void*)num_signal_pattern[translate_num(arg[5])], 2);
    memcpy(display_pattern[6], (void*)num_signal_pattern[translate_num(arg[6])], 2);
    memcpy(display_pattern[7], (void*)num_signal_pattern[translate_num(arg[7])], 2);
  
    //recover dot
    for(char n = 0; n < 8; n++){
      display_pattern[n][0] = (display_pattern[n][0] | dot_save[n]);
    }
  }
  
  void set_dot(){
    char* arg = SCmd.next();
  
    display_pattern[0][0] = ((display_pattern[0][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[0])][0]);
    display_pattern[1][0] = ((display_pattern[1][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[1])][0]);
    display_pattern[2][0] = ((display_pattern[2][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[2])][0]);
    display_pattern[3][0] = ((display_pattern[3][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[3])][0]);
    display_pattern[4][0] = ((display_pattern[4][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[4])][0]);
    display_pattern[5][0] = ((display_pattern[5][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[5])][0]);
    display_pattern[6][0] = ((display_pattern[6][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[6])][0]);
    display_pattern[7][0] = ((display_pattern[7][0] & 0b11111100) | dot_signal_pattern[translate_num(arg[7])][0]);
  }
  
  void error(){
    Serial.println("ubnrecongized command");
  }
  
  void loop(){
    SCmd.readSerial();
  }
\end{lstlisting}

\begin{lstlisting}[caption=SerialCommand.h,label=SerialCommand.h,language=C]
  #warning "Warning: Building SerialCommand without SoftwareSerial Support"
  #endif
  
  #ifndef SERIALCOMMAND_HARDWAREONLY 
  #include <SoftwareSerial.h>  
  #endif
  
  #include <string.h>
  
  
  #define SERIALCOMMANDBUFFER 32
  #define MAXSERIALCOMMANDS	10
  #define MAXDELIMETER 2
  
  #define SERIALCOMMANDDEBUG 1
  #undef SERIALCOMMANDDEBUG      // Comment this out to run the library in debug mode (verbose messages)
  
  class SerialCommand
  {
    public:
      SerialCommand();      // Constructor
      #ifndef SERIALCOMMAND_HARDWAREONLY
      SerialCommand(SoftwareSerial &SoftSer);  // Constructor for using SoftwareSerial objects
      #endif
  
      void clearBuffer();   // Sets the command buffer to all '\0' (nulls)
      char *next();         // returns pointer to next token found in command buffer (for getting arguments to commands)
      void readSerial();    // Main entry point.  
      void addCommand(const char *, void(*)());   // Add commands to processing dictionary
      void addDefaultHandler(void (*function)());    // A handler to call when no valid command received. 
    
    private:
      char inChar;          // A character read from the serial stream 
      char buffer[SERIALCOMMANDBUFFER];   // Buffer of stored characters while waiting for terminator character
      int  bufPos;                        // Current position in the buffer
      char delim[MAXDELIMETER];           // null-terminated list of character to be used as delimeters for tokenizing (default " ")
      char term;                          // Character that signals end of command (default '\r')
      char *token;                        // Returned token from the command buffer as returned by strtok_r
      char *last;                         // State variable used by strtok_r during processing
      typedef struct _callback {
        char command[SERIALCOMMANDBUFFER];
        void (*function)();
      } SerialCommandCallback;            // Data structure to hold Command/Handler function key-value pairs
      int numCommand;
      SerialCommandCallback CommandList[MAXSERIALCOMMANDS];   // Actual definition for command/handler array
      void (*defaultHandler)();           // Pointer to the default handler function 
      int usingSoftwareSerial;            // Used as boolean to see if we're using SoftwareSerial object or not
      #ifndef SERIALCOMMAND_HARDWAREONLY 
      SoftwareSerial *SoftSerial;         // Pointer to a user-created SoftwareSerial object
      #endif
  };
  
  #endif //SerialCommand_h
\end{lstlisting}

\begin{lstlisting}[caption=SerialCommand.cpp,label=SerialCommand.c,language=C]
  /******************************************************************************* 
  SerialCommand - An Arduino library to tokenize and parse commands received over
  a serial port. 
  Copyright (C) 2011-2013 Steven Cogswell  <steven.cogswell@gmail.com>
  http://awtfy.com
  
  See SerialCommand.h for version history. 
  
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  ***********************************************************************************/
  
  #if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
  #else
  #include "WProgram.h"
  #endif
  
  #include "SerialCommand.h"
  
  
  #include <string.h>
  #ifndef SERIALCOMMAND_HARDWAREONLY
  #include <SoftwareSerial.h>
  #endif
  
  // Constructor makes sure some things are set. 
  SerialCommand::SerialCommand()
  {
    usingSoftwareSerial=0;
    strncpy(delim," ",MAXDELIMETER);  // strtok_r needs a null-terminated string
    term='\r';   // return character, default terminator for commands
    numCommand=0;    // Number of callback handlers installed
    clearBuffer(); 
  }
  
  #ifndef SERIALCOMMAND_HARDWAREONLY
  // Constructor to use a SoftwareSerial object
  SerialCommand::SerialCommand(SoftwareSerial &_SoftSer)
  {
    usingSoftwareSerial=1; 
    SoftSerial = &_SoftSer;
    strncpy(delim," ",MAXDELIMETER);  // strtok_r needs a null-terminated string
    term='\r';   // return character, default terminator for commands
    numCommand=0;    // Number of callback handlers installed
    clearBuffer(); 
  }
  #endif
  
  
  //
  // Initialize the command buffer being processed to all null characters
  //
  void SerialCommand::clearBuffer()
  {
    for (int i=0; i<SERIALCOMMANDBUFFER; i++) 
    {
      buffer[i]='\0';
    }
    bufPos=0; 
  }
  
  // Retrieve the next token ("word" or "argument") from the Command buffer.  
  // returns a NULL if no more tokens exist.   
  char *SerialCommand::next() 
  {
    char *nextToken;
    nextToken = strtok_r(NULL, delim, &last); 
    return nextToken; 
  }
  
  // This checks the Serial stream for characters, and assembles them into a buffer.  
  // When the terminator character (default '\r') is seen, it starts parsing the 
  // buffer for a prefix command, and calls handlers setup by addCommand() member
  void SerialCommand::readSerial() 
  {
    // If we're using the Hardware port, check it.   Otherwise check the user-created SoftwareSerial Port
    #ifdef SERIALCOMMAND_HARDWAREONLY
    while (Serial.available() > 0) 
    #else
    while ((usingSoftwareSerial==0 && Serial.available() > 0) || (usingSoftwareSerial==1 && SoftSerial->available() > 0) )
    #endif
    {
      int i; 
      boolean matched; 
      if (usingSoftwareSerial==0) {
        // Hardware serial port
        inChar=Serial.read();   // Read single available character, there may be more waiting
      } else {
        #ifndef SERIALCOMMAND_HARDWAREONLY
        // SoftwareSerial port
        inChar = SoftSerial->read();   // Read single available character, there may be more waiting
        #endif
      }
      #ifdef SERIALCOMMANDDEBUG
      Serial.print(inChar);   // Echo back to serial stream
      #endif
      if (inChar==term) {     // Check for the terminator (default '\r') meaning end of command
        #ifdef SERIALCOMMANDDEBUG
        Serial.print("Received: "); 
        Serial.println(buffer);
          #endif
        bufPos=0;           // Reset to start of buffer
        token = strtok_r(buffer,delim,&last);   // Search for command at start of buffer
        if (token == NULL) return; 
        matched=false; 
        for (i=0; i<numCommand; i++) {
          #ifdef SERIALCOMMANDDEBUG
          Serial.print("Comparing ["); 
          Serial.print(token); 
          Serial.print("] to [");
          Serial.print(CommandList[i].command);
          Serial.println("]");
          #endif
          // Compare the found command against the list of known commands for a match
          if (strncmp(token,CommandList[i].command,SERIALCOMMANDBUFFER) == 0) 
          {
            #ifdef SERIALCOMMANDDEBUG
            Serial.print("Matched Command: "); 
            Serial.println(token);
            #endif
            // Execute the stored handler function for the command
            (*CommandList[i].function)(); 
            clearBuffer(); 
            matched=true; 
            break; 
          }
        }
        if (matched==false) {
          (*defaultHandler)(); 
          clearBuffer(); 
        }
  
      }
      if (isprint(inChar))   // Only printable characters into the buffer
      {
        buffer[bufPos++]=inChar;   // Put character into buffer
        buffer[bufPos]='\0';  // Null terminate
        if (bufPos > SERIALCOMMANDBUFFER-1) bufPos=0; // wrap buffer around if full  
      }
    }
  }
  
  // Adds a "command" and a handler function to the list of available commands.  
  // This is used for matching a found token in the buffer, and gives the pointer
  // to the handler function to deal with it. 
  void SerialCommand::addCommand(const char *command, void (*function)())
  {
    if (numCommand < MAXSERIALCOMMANDS) {
      #ifdef SERIALCOMMANDDEBUG
      Serial.print(numCommand); 
      Serial.print("-"); 
      Serial.print("Adding command for "); 
      Serial.println(command); 
      #endif
      
      strncpy(CommandList[numCommand].command,command,SERIALCOMMANDBUFFER); 
      CommandList[numCommand].function = function; 
      numCommand++; 
    } else {
      // In this case, you tried to push more commands into the buffer than it is compiled to hold.  
      // Not much we can do since there is no real visible error assertion, we just ignore adding
      // the command
      #ifdef SERIALCOMMANDDEBUG
      Serial.println("Too many handlers - recompile changing MAXSERIALCOMMANDS"); 
      #endif 
    }
  }
  
  // This sets up a handler to be called in the event that the receveived command string
  // isn't in the list of things with handlers.
  void SerialCommand::addDefaultHandler(void (*function)())
  {
    defaultHandler = function;
  }
\end{lstlisting}